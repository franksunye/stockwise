---
name: incremental-upgrade
description: 安全的增量升级策略 - 在重构、优化、升级时确保现有功能完整保留，避免"实现新功能，破坏旧功能"的问题。
---

# 增量升级原则 (Incremental Upgrade Principles)

## 核心理念

> **永远不要在添加新功能时移除或简化现有的工作代码。**
> 
> 历史教训：在 `a4f682a` 提交中，身份恢复功能重构时简化了推送通知代码，导致原本工作的功能失效。

## ⚠️ 必须遵守的规则

### 1. 黄金法则：增量添加，而非替换

```
❌ 错误做法：
- 看到"复杂"的代码就想简化
- 用"更优雅"的新实现替换旧代码
- 假设某些步骤"不需要"而省略

✅ 正确做法：
- 在现有代码基础上添加新功能
- 保留所有现有的工作逻辑
- 新旧代码共存，充分测试后再考虑移除
```

### 2. 重构前的强制检查清单

在修改任何现有功能代码之前，必须回答以下问题：

- [ ] **我完全理解这段代码的每一行在做什么吗？**
- [ ] **我知道为什么原作者要写这些步骤吗？**
- [ ] **移除任何一行会导致什么后果？**
- [ ] **有没有隐藏的依赖关系我没有发现？**

如果任何一项回答是"不确定"，**不要修改**。

### 3. 分阶段升级策略

```
阶段 1：添加新功能 (Addition)
├── 保留所有现有代码
├── 在新位置添加新功能
└── 确保新旧功能可以共存

阶段 2：验证 (Validation)  
├── 测试所有现有功能是否正常
├── 测试新功能是否正常
└── 回归测试边缘情况

阶段 3：可选优化 (Optional Optimization)
├── 只有在充分验证后才考虑
├── 如果旧代码工作正常，可以不动
└── "如果没坏，不要修"
```

### 4. 代码对比检查

在提交重构代码前，必须执行：

```bash
# 对比重构前后的功能函数
git show <上一个工作版本>:<文件路径> | Select-String "<函数名>" -Context 0,50

# 逐行对比，确认：
# 1. 没有遗漏任何步骤
# 2. 没有改变执行顺序
# 3. 没有移除错误处理
```

### 5. 高风险区域标记

以下区域需要**格外谨慎**：

| 区域       | 风险原因   | 处理方式                         |
| ---------- | ---------- | -------------------------------- |
| 认证/授权  | 涉及安全   | 绝不简化，只增加日志             |
| 支付流程   | 涉及金钱   | 完全保留，新增功能独立           |
| 推送通知   | 多步骤依赖 | 保留 SW 注册、权限请求等完整流程 |
| 数据迁移   | 不可逆     | 先备份，分批执行                 |
| 第三方 API | 外部依赖   | 保留重试、错误处理逻辑           |

### 6. 常见错误模式

#### ❌ 模式 1：过度简化

```typescript
// 原始代码（工作正常）
const registration = await registerServiceWorker();
if (!registration) return;
const perm = await Notification.requestPermission();
if (perm === 'granted') {
  const subscription = await pushManager.getSubscription();
  if (!subscription) {
    subscription = await subscribeUserToPush(vapidKey);
  }
}

// 错误的"简化"
const subscription = await subscribeUserToPush(vapidKey); // 跳过了多个关键步骤！
```

#### ❌ 模式 2：假设等价

```typescript
// 原始代码
body: JSON.stringify({ userId, subscription: subscription.toJSON() })

// 错误假设"应该一样"
body: JSON.stringify({ userId, subscription }) // .toJSON() 被遗漏了！
```

#### ❌ 模式 3：移除"无用"状态

```typescript
// 原始代码
const [_permission, setPermission] = useState('default');
// 在多处调用 setPermission(...)

// 错误判断"下划线变量无用"，直接删除
// 结果：其他地方的 setPermission 调用报错！
```

## 实践案例

### 案例：推送通知功能被破坏

**背景**：在实现"身份恢复系统"时，重构了 `handleEnableNotifications` 函数。

**问题**：原始代码有 7 个步骤，重构后只剩 3 个步骤。

| 步骤                   | 原始版本 | 重构后 | 后果      |
| ---------------------- | -------- | ------ | --------- |
| 1. 获取 userId         | ✅        | ❌ 移除 | -         |
| 2. 检查 VAPID Key      | ✅        | ✅      | -         |
| 3. 注册 Service Worker | ✅        | ❌ 移除 | SW 未注册 |
| 4. 请求权限            | ✅        | ❌ 移除 | 没有权限  |
| 5. 获取现有订阅        | ✅        | ❌ 移除 | 重复订阅  |
| 6. 创建新订阅          | ✅        | ✅      | -         |
| 7. 保存到后端          | ✅        | ✅      | -         |

**结果**：推送通知功能完全失效，用户无法开启通知。

**教训**：
1. 不要因为"看起来简单"就简化代码
2. 每个步骤都可能有存在的理由
3. 测试环境可能掩盖问题（本地 SW 已缓存）

## 检查工具

### 函数完整性检查脚本

当需要重构某个函数时，使用以下命令检查原始实现：

```powershell
# 查看原始函数实现
git show HEAD~1:path/to/file.ts | Select-String "functionName" -Context 0,100

# 对比两个版本
git diff HEAD~1 HEAD -- path/to/file.ts
```

## 总结

| 原则     | 描述                           |
| -------- | ------------------------------ |
| 增量优先 | 添加新功能，不删除旧功能       |
| 理解为先 | 不理解的代码不要动             |
| 测试验证 | 修改后必须测试所有相关功能     |
| 保守策略 | 宁可代码"冗余"，也不冒险"简化" |
| 案例学习 | 从历史问题中吸取教训           |

---

*创建于：2026-01-27*
*触发事件：推送通知功能在身份恢复重构中被意外破坏*
