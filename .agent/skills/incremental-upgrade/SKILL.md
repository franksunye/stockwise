---
name: incremental-upgrade
description: 安全的增量升级策略 - 在重构、优化、升级时确保现有功能完整保留，避免"实现新功能，破坏旧功能"及类型系统的破坏。
---

# 增量升级与类型安全原则 (Safe Incremental Upgrade & Type Safety)

## 核心理念

> **1. 永远不要在添加新功能时移除或简化现有的工作代码。**
> **2. `any` 是魔鬼。尽量消除它，而不是压制它。**

## ⚠️ 必须遵守的规则

### 1. 黄金法则：增量添加，而非替换

```
❌ 错误做法：
- 看到"复杂"的代码就想简化
- 用"更优雅"的新实现替换旧代码
- 假设某些步骤"不需要"而省略

✅ 正确做法：
- 在现有代码基础上添加新功能
- 保留所有现有的工作逻辑
- 新旧代码共存，充分验证后再考虑移除
```

### 2. 类型安全零容忍 (Zero Tolerance for `any`)

TypeScript 的核心价值在于类型检查。使用 `any` 等同于你在代码中埋下了一颗由于"未知类型"导致的运行时地雷。

*   **严禁显式 `any`**：除非是处理极其动态的第三方库且无法获取类型定义，否则不允许使用 `any`。
*   **使用 `unknown` 代替 `any`**：如果你不知道类型是什么，使用 `unknown`，然后在使用前进行类型收窄 (Type Narrowing)。
*   **不要压制 ESLint**：看到 `eslint-disable` 警告时，解决问题，而不是隐藏警告。

### 3. 重构前的强制检查清单

在修改任何现有功能代码之前，由 Agent 自我审视：

- [ ] **功能完整性**：我完全理解这段代码的每一行在做什么吗？我知道为什么原作者要写这些步骤吗？
- [ ] **类型安全性**：我是否引入了新的 `any`？我是否正确定义了接口？
- [ ] **副作用检查**：移除这行代码会影响其他依赖它的状态吗？(例如：移除了 `useState` 定义但保留了 `set` 调用)
- [ ] **构建预演**：修改后，Build 还能通过吗？

### 4. 分阶段升级策略

```
阶段 1：类型定义 (Type Definition)
├── 先定义 Interface / Type
├── 确保新旧数据结构的兼容性
└── 绝不破坏现有的类型推断

阶段 2：逻辑实现 (Implementation)
├── 保留所有现有步骤 (如 SW 注册、权限检查)
├── 在新位置插入新逻辑
└── 确保每一步都有日志记录

阶段 3：验证与清理 (Verification)
├── 运行相关功能的端到端测试
├── 检查 ESLint 并在本地尝试 Build
└── 只有在确认无误后，才移除废弃代码
```

### 5. 代码对比检查 (Agent Self-Correction)

在提交重构代码前，必须执行：

```bash
# 1. 检查原始逻辑
git show HEAD~1:path/to/file.ts | Select-String "functionName" -Context 0,50

# 2. 检查是否有 setXxx 调用指向了已删除的变量（常见错误）
grep "setVariableName" path/to/file.ts
```

### 6. 高风险区域标记

| 区域           | 风险原因   | 处理方式                             |
| -------------- | ---------- | ------------------------------------ |
| **认证/授权**  | 安全核心   | 绝不简化，只增加日志                 |
| **状态管理**   | 引用丢失   | 删除 state 前 grep 所有 set 调用     |
| **推送通知**   | 多步骤依赖 | 保留 SW 注册、权限请求等完整流程     |
| **第三方 API** | 类型不可控 | 必须定义对应的 Interface，禁止 `any` |

### 7. 常见错误模式库

#### ❌ 模式 1：过度简化 (Functionality Loss)
**现象**：为了让代码看起来"干净"，删除了看似冗余但实际必要的步骤（如 SW 注册）。
**后果**：功能直接失效。

#### ❌ 模式 2：幽灵引用 (Build Break)
**现象**：删除了 `const [status, setStatus] = useState(...)`，但代码深处还保留了 `setStatus('ok')`。
**后果**：构建失败 (ReferenceError / TypeScript Error)。

#### ❌ 模式 3：Any 逃生舱 (Type Unsafe)
**现象**：遇到类型错误，直接加 `// @ts-ignore` 或 `as any`。
**后果**：运行时崩溃，且难以调试。

#### ❌ 模式 4：忽略依赖 (Silent Failure)
**现象**：修改了 useEffect 的依赖项，或者移除了某些回调。
**后果**：逻辑不执行或无限循环。

## 总结

我们不仅是在写代码，更是在维护一个生态系统。每一次"简化"都必须建立在对现有逻辑 100% 理解的基础上。**看不懂的代码，不要删。**
